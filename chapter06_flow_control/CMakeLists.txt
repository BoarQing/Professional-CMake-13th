cmake_minimum_required(VERSION 3.22.1)
project(flow_control
		VERSION 1.0.0
		LANGUAGES C CXX)

set(cond ON)
if(cond)
    message("${cond} is evaluated to true")
endif()
set(cond YES)
if(cond)
    message("${cond} is evaluated to true")
endif()
set(cond TRUE)
if(cond)
    message("${cond} is evaluated to true")
endif()
set(cond Y)
if(cond)
    message("${cond} is evaluated to true")
endif()
#case in-sensitive
set(cond y)
if(cond)
    message("${cond} is evaluated to true")
endif()
#it is ok to not to add ${}
set(cond y)
if(${cond})
    message("${cond} is evaluated to true")
endif()
set(conda "a variable that is defined")
if(conda)
    message("${conda} is evaluated to true")
endif()

set(cond OFF)
if(NOT cond)
    message("${cond} is evaluated to false")
endif()
set(cond FALSE)
if(NOT cond)
    message("${cond} is evaluated to false")
endif()
set(cond N)
if(NOT cond)
    message("${cond} is evaluated to false")
endif()
set(cond IGNORE)
if(NOT cond)
    message("${cond} is evaluated to false")
endif()
set(cond NOTFOUND)
if(NOT cond)
    message("${cond} is evaluated to false")
endif()
set(cond MYCMAKESKILL-NOTFOUND)
if(NOT cond)
    message("${cond} is evaluated to false")
endif()
set(x 2)
set(y 0)
math(EXPR cond "${x} * ${y}")
if(NOT cond)
    message("math value 0 is evaluated to false")
endif()
if(NOT "condb")
    message("a string itself that does not match any variable is false")
endif()

set(ENV{PATH} TRUE)
#compile error
#if ($ENV{PATH})



set(a 1)
set(b 2)
set(c 3)
if(a AND b AND c)
    message("${a} ${b} ${c} are all true")
endif()
set(d 0)

if(a OR d)
    message("${a} OR ${d} are true")
endif()
set(a_version "1.2")
set(b_version "1.3")
if(${a_version} LESS ${b_version})
    message("number less")
endif()
if(${a_version} STRLESS ${b_version})
    message("string less")
endif()
if(${a_version} VERSION_LESS ${b_version})
    message("version less")
endif()
#support only after 3.24
#if ("/a//b/c" PATH_EQUAL "/a/b/c")
#endif()


set(who Barney)
if("Hi from ${who}" MATCHES "Hi from (Fred|Barney).*")
    message("${CMAKE_MATCH_1} says hello")
endif()


set(p "CMakeLists.txt")
if (EXISTS ${p})
    message("${p} exists")
endif()
set(p "/")
if (IS_DIRECTORY ${p})
    message("${p} is a directory")
endif()
set(p "CMakeLists.txt")
if (NOT IS_SYMLINK ${p})
    message("${p} is not a symbol link")
endif()
set(p "/")
if (IS_ABSOLUTE ${p})
    message("${p} is an absolute path")
endif()
if (${p} IS_NEWER_THAN ${p})
    message("${p} is the same file but is_newer_than evaluated to true")
endif()



set(a a)
set(b CACHE STRING b)
if(DEFINED a)
    message("${a} is defined")
endif()
if(DEFINED b)
    message("cached ${b} is defined")
endif()
if(DEFINED ENV{PATH})
    message("ENV ${PATH} is defined")
endif()
set(x 1 2 3)
if(1 IN_LIST x)
    message("1 in list x")
endif()
#function or macro
if (COMMAND set)
    message("command set exist")
endif()
if (NOT COMMAND lalala)
    message("command lalala does not exist")
endif()
if(NOT POLICY null)
    message("policy null does not exist")
endif()
if(NOT TARGET null)
    message("target null does not exist")
endif()
if(NOT POLICY null)
    message("policy null does not exist")
endif()



if(WIN32)
else()
    message("not win32 platform")
endif()
if(WIN32)
else()
    message("not MVSC")
endif()
if(APPLE)
else()
    message("not apple")
endif()
message("CMAKE_GENERATOR is ${CMAKE_GENERATOR}")



set(list1 A B)
set(list2)
set(foo WillNotBeShown)
foreach(loopVar IN LISTS list1)
    message("Iteration for: ${loopVar}")
endforeach()
foreach(loopVar IN LISTS list1 list2 ITEMS foo)
    message("Iteration for: ${loopVar}")
endforeach()
#default is string
foreach(loopVar IN LISTS list1 list2 ITEMS foo bar)
    message("Iteration for: ${loopVar}")
endforeach()
foreach(loopVar IN LISTS list1 list2 ITEMS ${foo} bar)
    message("Iteration for: ${loopVar}")
endforeach()
set(list0 A B)
set(list1 one two)
#multi list same time
foreach(var0 var1 IN ZIP_LISTS list0 list1)
    message("Vars: ${var0} ${var1}")
endforeach()
foreach(var IN ZIP_LISTS list0 list1)
#var -> var_0
message("Vars: ${var_0} ${var_1}")
endforeach()
set(long A B C)
set(short justOne)
foreach(varLong varShort IN ZIP_LISTS long short)
    message("Vars: ${varLong} ${varShort}")
endforeach()



foreach(loopVar RANGE 0 10 3)
    message("loopVar is ${loopVar}")
endforeach()
foreach(loopVar RANGE 0 10)
    message("loopVar is ${loopVar}")
endforeach()
set(x 10)
while(x)
    math(EXPR x "${x} - 1")
    message("x in while loop ${x}")
endwhile()
